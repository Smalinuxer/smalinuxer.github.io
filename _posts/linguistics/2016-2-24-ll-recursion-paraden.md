---
layout: post
title: 语法解析(二)LL递归下降词法分析器
category: linguistics
keywords: linguistics,LL,语法分析
---

# 0x01.前言

学完了上下文无关的语法解析后,是不是觉得很方便去做DSL呀

这章介绍几种模式去分析语言结构

# 0x02.LL常见解析模式
 
 
   本节介绍**手工编写的语言识别器时常见的解析器设计模式**,由于各种语言的解析难度不一样,因此有多种解析模式

- 模式一:从文法到递归下降识别器,这种模式展示了**将文法(形式化的语言定义)手动转化成解析器**的过程,后面3种模式会用到
- 模式二:LL(1)递归下降词法分析器,这种模式把**字符流分解为词法单元(token)**,以后后面解析模式使用
- 模式三:LL(1)递归下降语法解析器,它只根据**当前的输入字符串来决定如何解析,并且对文法中的每条规则都提供相应的解析方法**
- 模式四:LL(k)递归下降语法解析器,这是对模式三的增强,他**最多向前看k个输入字符来决定如何解析**


# 0x03.词法单元和解析

现在我具有这么一颗语法抽象树,即表示[a,b,c]和[a,[b,c],d]需要用四种模式来解析这种抽象语法单元

如图:

![1](http://7xkw0v.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-17%20%E4%B8%8B%E5%8D%881.58.37.png)

## 0x031.模式一:从文法到递归下降识别器

这种模式相对来说比较简单,其由简单的正则加自动机组成,我就不介绍了

## 0x032.模式二:LL(1)递归下降词法分析器

**实现:足个读出语法单元,直到文本内容结束**

其主体思想是想将一个个词法单元分解成token,再让下面的及分析其去分析一个个的token

主要代码:

```JAVA
ListLexer lexer = new ListLexer(args[0]);
Token t = lexer.nextToken();
while(t.type != Lexer.EOF_TYPE){
	System.out.println(t);
	t = lexer.nextToken();
}
System.out.println(t);

```


打印:

```
<'[',LBRACK>
<'a',NAME>
<',',COMMA>
<'b',NAME>
<']',RBRACK>
<'<EOF>',<EOF>>

```

## 0x033.模式三:LL(1)递归下降语法解析器

这种模式主要展示了如何根据一个向前看词法单元来决定解析方式.

**实现:解析器得到当前的向前看词法单元之后,会对解析选项的向前看集合分别进行测试**

其面向的是词法单元(token),对模式二分解之后的词法单元进行解析

     BNF :
          list : ‘[‘ elements ‘]' ;                 // 向前看的集合是elements
          elements : element (‘,’ element)* ;      // 向前看的集合是element
          element : NAME | list ;                   // 想前看的集合是Name或者List


例一[a,b,c]

其构建成语法树由**最左推倒**表示:

![D1](http://7xkw0v.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-22%20%E4%B8%8B%E5%8D%8810.56.00.png)

上下无关推到式:

		E -> '[' F ']'
		F -> D (',' D)*
		D -> NAME | E

                     E
                     |
                  '['F']'
                  /  |  \
                 D   D   D
                 |   |   |
                 a   b   c


例二[a,[b,c],d]

其构建成语法树由**最左推倒**表示:

![D1](http://7xkw0v.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-22%20%E4%B8%8B%E5%8D%8811.01.49.png)

                E
                |
            '[' F ']'
            /   |  \
           D    D   D
           |    |	 |
           a    E   d
                |
            '[' F ']'
              /   \
             b     c
             

相关代码:[http://pan.baidu.com/s/1dEr8njN](http://pan.baidu.com/s/1dEr8njN)


## 0x034.LL(k)递归下降语法解析器

和模式三唯一的不同是:其有一个环形的向前缓冲区,其可以提供多个token作为前趋的条件

为了更好地缓存输入的token,我们创建了一种环形的向前缓冲区.

其用数组缓冲所有的输入符号,以整数下表作为当前输入元素的指针,比如缓冲区中的第p个元素.处理完当前词法单元后执行p++就好.之后的k个向前看符号就表示为tokens[p],tokens[p+1],···,tokens[p+k-1].

比如缓冲[a,b=c]这个序列缓冲区大小为3

则缓冲区一开始:

	[ a ,			//指针指向[
	


当一个一个消耗掉token:

	b a ,  			//指针指向a
	b = ,			//指针指向,
	b = c			//指针指向b
	] = c			//指针指向=
	] = c			//指针指向c,由于无更多缓冲数据,则=不会被覆盖
	] = c			//指针指向],消耗则结束
	

**其实构建环形的向前的缓冲区,只是为了让多个token合并成一个token来进行向前下降解析,这也是和模式三唯一的不同**

其余的和模式一可以说是相同的解析方式

相关解析代码:[http://pan.baidu.com/s/1bmoBLk](http://pan.baidu.com/s/1bmoBLk)




