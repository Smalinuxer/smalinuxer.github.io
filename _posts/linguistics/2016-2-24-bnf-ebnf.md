---
layout: post
title: 语法解析(一)BNF&EBNF
category: linguistics
keywords: linguistics,上下文无关,BNF,EBNF
---


# 0x01. 上下文无关的语法

## 0x011.上文无关的语法定义

若一个形式文法 G = (N, Σ, P, S) 的产生式规则都取如下的形式：V -> w，则称之为上下文无关文法（英语：context-free grammar，缩写为CFG），其中 V ∈ N ，w∈(N∪Σ)* 。上下文无关文法取名为“上下文无关”的原因就是因为**字符V总可以被字串w自由替换**，而无需考虑字符V出现的上下文。一个形式语言是上下文无关的，如果它是由上下文无关文法生成的。

## 0x012.产生式与推导

产生式是上下文无关语法的一种定义方式,一个产生式由**非终结符**、**终结符**以及**推倒过程**组成,而多个产生式可以组成上下文无关语法规则.

> * 非终结符（nonterminal symbol）: 可以继续产生新符号的“文法变量”
> * 终结符（terminal symbol）: 具有固定意义的元素,它们不再推倒出新的东西
> * 推导 : 由非终结符变化成非终结符或和终结符组成的过程,有**最左推导**和**最右推导**

比如要用产生式来表达a+b

	E -> E+E
	E -> data

在本例中, E为**非终结符**,而data表示**终结符**

## 0x013.最左最右推导

在推导过程中先将最左子树上的节点进行推导的过程称为**最左推导**,而在推导过程中先将最右子树上的节点进行推导的过程称为**最右推导**

比如存在产生式


	E -> E+E
	E -> data

存在语句

	a+b+c
	


	
最左推导过程为:
	
		   E
		 / | \
		E  +  E
	  / | \   |
	 a  +  b  c

最右推导过程为:

		   E
		 / | \
		E  +  E
		|	/ | \
	 	a  b  +  c


本例中推导出的结果一样,但是如果遇到存在**优先级**的例子则会有大不同


## 0x013.优先级问题

同一条语句,是会因为推导过程的不同而导致结果不一致的问题的.所以我们需要制定哪些是先执行的语句token

比如看下面这个例子

比如存在产生式

	E -> E*E
	E -> E+E
	E -> data


存在语句
	
	a * b + c
	
向左推导
	
		   E
		 / | \
		E  +  E
	  / | \   |
	 a  *  b  c
	 
向右推导

		   E
		 / | \
		E  *  E
		|	/ | \
	 	a  b  +  c
	 	
可以明显看出来这两者的结果是不一样的,因为算数优先级的不同导致的结果也不同

一般有两种思路解决优先级问题

> * 产生自己的推导过程
> * 修改已经有的产生式


**产生自己的推导过程**,这点比较困难,实用性不强,只能在一些略微简单的文法中使用,但遇到复杂的文法就很难表达.解决上面例子的问题就只需要在推导过程中优先推导E -> E*E这个规则即可

**修改已经有的产生式**,而这个方法比较普遍,上述例子中产生式可以修改如下

	F → data
	T → T * F
	T → F
	E → E + T
	E → T


则就只存在一种推导树

			  E
			/ | \
		   E  +	 T
		   |   / | \
		   T  T  *  F
		   |  |  	|
		   F  F		a
		   |  |
		   c  b

# 0x02.BNF&EBNF

## 0x021.简介

巴科斯范式（英语：Backus Normal Form，缩写为 BNF），又称为巴科斯-诺尔范式（英语：Backus-Naur Form，缩写同样为 BNF，也译为巴科斯-瑙尔范式、巴克斯-诺尔范式），是一种用于表示上下文无关文法的语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。简单说就是“一种通用描述规则，用来描述各种计算机语言语法定义”。

后来在RFC2234/RFC4234中又定义了扩充的巴科斯范式（EBNF），再后来又在RFC5234中再定义了扩展的巴科斯范式（ABNF），RFC5234取代了RFC4234 和RFC2234。

扩展的巴科斯使巴科斯范式更加完善。 现在，几乎所有的IT编程语言书籍或IETF在编写RFC等规范文档 等时候，你都可以看到作者使用巴科斯范式及其扩展来定义某一个语法规则 或 变量格式。 下文对巴科斯范式或扩展的巴科斯范式，都称为 巴科斯范式 或 BNF

同时他也是作为anltr基础语法

## 0x022.BNF

在BNF中，双引号中的字("word")代表着这些字符本身。而double_quote用来代表双引号。在双引号外的字（有可能有下划线）代表着语法部分。

> * < > : 内包含的为必选项。
> * [ ] : 内包含的为可选项。
> * { } : 内包含的为可重复0至无数次的项。
> * |  : 表示在其左右两边任选一项，相当于"OR"的意思。
> * ::= : 是“被定义为”的意思
> * "..." : 术语符号
> * [...] : 选项，最多出现一次
> * {...} : 重复项，任意次数，包括 0 次
> * (...) : 分组
> * | : 并列选项，只能选一个
> * 斜体字: 参数，在其它地方有解释



下面是是用BNF来定义的Java语言中的For语句的实例：

```JAVA
FOR_STATEMENT ::=
"for" "(" ( variable_declaration | ( expression ";" ) | ";" )  [ expression ] ";" [ expression ] ";" ")"
    statement
```    


## 0x023.EBNF

EBNF为BNF的扩展语法集合

主要用来解决**可选项和重复不能直接表达**的问题

以下节选自维基百科

依据 ISO 14977 标准，提供了两个设施来扩展 EBNF。其一是在 EBNF 文法部分的特殊序列，它是在问号包围内的任意文本，其解释超出了 EBNF 标准的范围。例如，空格字符可以用如下规则定义:

```
space = ? US-ASCII character 32 ?;
```

其二利用圆括号在 EBNF 中不能放置到紧随标识符之后的事实。下列不是有效的 EBNF:

```
something = foo ( bar );
```

所以 EBNF 的扩展可以使用这种表示法。例如，在 Lisp 文法中，函数应用可以用如下规则定义:

```
function application = list( symbol , [ { expression } ] );
```

